import axios from 'axios';

const Environments = {
  production: "production",
  sandbox: "sandbox",
  dev: "dev"
};
class Configuration {
  baseURL;
  apiKey;
  onResponse;
  onRequest;
  constructor(opts) {
    Configuration._validateConfiguration(opts);
    this.baseURL = `https://${opts.env}.methodfi.com`;
    this.apiKey = opts.apiKey;
    this.onRequest = opts.onRequest || null;
    this.onResponse = opts.onResponse || null;
  }
  addPath(path) {
    const clone = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
    clone.baseURL = `${clone.baseURL}/${path}`;
    return clone;
  }
  static _validateConfiguration(opts) {
    if (!Environments[opts.env])
      throw new Error(`Invalid env: ${opts.env}`);
    if (!opts.apiKey)
      throw new Error(`Invalid apiKey: ${opts.apiKey}`);
  }
}

const MethodErrorTypes = {
  INVALID_AUTHORIZATION: "INVALID_AUTHORIZATION",
  INVALID_REQUEST: "INVALID_REQUEST",
  API_ERROR: "API_ERROR"
};
class MethodError extends Error {
  type;
  sub_type;
  message;
  code;
  constructor(opts) {
    super();
    this.type = opts.type;
    this.sub_type = opts.sub_type;
    this.message = opts.message;
    this.code = opts.code;
  }
  static generate(opts) {
    switch (opts.type) {
      case MethodErrorTypes.API_ERROR:
        return new MethodInternalError(opts);
      case MethodErrorTypes.INVALID_REQUEST:
        return new MethodInvalidRequestError(opts);
      case MethodErrorTypes.INVALID_AUTHORIZATION:
        return new MethodAuthorizationError(opts);
    }
  }
}
class MethodInternalError extends MethodError {
}
class MethodInvalidRequestError extends MethodError {
}
class MethodAuthorizationError extends MethodError {
}

class ExtensibleFunction extends Function {
  constructor(f) {
    return Object.setPrototypeOf(f, new.target.prototype);
  }
}
class Resource extends ExtensibleFunction {
  client;
  config;
  constructor(config) {
    super((id) => this._call(id));
    this.config = config;
    this.client = axios.create({
      baseURL: config.baseURL,
      headers: { Authorization: `Bearer ${config.apiKey}`, "User-Agent": this.getDefaultUserAgent() }
    });
    this.configureRequestInterceptors();
    this.configureResponseInterceptors();
  }
  getDefaultUserAgent() {
    return `Method-Node/v${require("../package.json").version}`;
  }
  configureRequestInterceptors() {
    this.client.interceptors.request.use((request) => {
      request.headers["request-start-time"] = Date.now();
      if (this.config.onRequest) {
        this.config.onRequest({
          method: request.method.toUpperCase(),
          idempotency_key: request.headers["Idempotency-Key"] || null,
          path: new URL(`${request.baseURL}${request.url}`).pathname,
          request_start_time: request.headers["request-start-time"]
        });
      }
      return request;
    });
  }
  configureResponseInterceptors() {
    const extractResponseEvent = (response) => {
      const payload = {
        request_id: response.headers["idem-request-id"] || null,
        idempotency_status: response.headers["idem-status"] || null,
        method: response.config.method.toUpperCase(),
        path: new URL(`${response.config.baseURL}${response.config.url}`).pathname,
        status: response.status,
        request_start_time: response.config.headers["request-start-time"],
        request_end_time: Date.now(),
        pagination: {
          page: 1,
          page_count: 1,
          page_limit: 1,
          total_count: 1,
          page_cursor_next: null,
          page_cursor_prev: null
        }
      };
      if (response.headers["pagination-page"])
        payload.pagination.page = Number(response.headers["pagination-page"]);
      if (response.headers["pagination-page-count"])
        payload.pagination.page_count = Number(response.headers["pagination-page-count"]);
      if (response.headers["pagination-page-limit"])
        payload.pagination.page_limit = Number(response.headers["pagination-page-limit"]);
      if (response.headers["pagination-total-count"])
        payload.pagination.total_count = Number(response.headers["pagination-total-count"]);
      if (response.headers["pagination-page-cursor-next"])
        payload.pagination.page_cursor_next = response.headers["pagination-page-cursor-next"];
      if (response.headers["pagination-page-cursor-prev"])
        payload.pagination.page_cursor_prev = response.headers["pagination-page-cursor-prev"];
      return payload;
    };
    this.client.interceptors.response.use((response) => {
      if (this.config.onResponse)
        this.config.onResponse(extractResponseEvent(response), response);
      return response;
    }, (error) => {
      if (this.config.onResponse && error.response) {
        this.config.onResponse(extractResponseEvent(error.response), error.response);
      }
      if (error.response && error.response.data && error.response.data.data)
        throw MethodError.generate(error.response.data.data.error);
      throw error;
    });
  }
  _call(id) {
    throw new Error();
  }
  async _getRaw() {
    return (await this.client.get("")).data;
  }
  async _get() {
    return (await this.client.get("")).data.data;
  }
  async _getWithId(id) {
    return (await this.client.get(`/${id}`)).data.data;
  }
  async _getWithSubPath(path) {
    return (await this.client.get(path)).data.data;
  }
  async _getWithParams(params) {
    return (await this.client.get("", { params })).data.data;
  }
  async _list(params) {
    return (await this.client.get("", { params })).data.data;
  }
  async _create(data, requestConfig = {}) {
    const _requestConfig = { headers: {} };
    if (requestConfig.idempotency_key)
      _requestConfig.headers = { "Idempotency-Key": requestConfig.idempotency_key };
    return (await this.client.post("", data, _requestConfig)).data.data;
  }
  async _createWithSubPath(path, data, requestConfig = {}) {
    if (requestConfig.idempotency_key)
      ({ "Idempotency-Key": requestConfig.idempotency_key });
    return (await this.client.post(path, data)).data.data;
  }
  async _updateWithId(id, data) {
    return (await this.client.put(`/${id}`, data)).data.data;
  }
  async _update(data) {
    return (await this.client.put("", data)).data.data;
  }
  async _updateWithSubPath(path, data, requestConfig = {}) {
    if (requestConfig.idempotency_key)
      ({ "Idempotency-Key": requestConfig.idempotency_key });
    return (await this.client.put(path, data)).data.data;
  }
  async _delete(id) {
    return (await this.client.delete(`/${id}`)).data.data;
  }
  async _deleteWithSubPath(path, data, requestConfig = {}) {
    return (await this.client.delete(path, data)).data.data;
  }
  async _download(id) {
    return (await this.client.get(`/${id}/download`)).data;
  }
  async _postWithId(id, data) {
    return (await this.client.post(`/${id}`, data)).data.data;
  }
}

class Verification extends Resource {
  constructor(config) {
    super(config.addPath("verification"));
  }
  async get() {
    return super._get();
  }
  async create(data, requestConfig) {
    return super._create(data, requestConfig);
  }
  async update(data) {
    return super._update(data);
  }
  async getTestAmounts() {
    return super._getWithSubPath("/amounts");
  }
}

class AccountSync extends Resource {
  constructor(config) {
    super(config.addPath("syncs"));
  }
  async get(id) {
    return super._getWithId(id);
  }
  async create(data) {
    return super._create(data);
  }
}

const AccountTypes = {
  ach: "ach",
  liability: "liability",
  clearing: "clearing"
};
const AccountSubTypes = {
  savings: "savings",
  checking: "checking"
};
const AccountClearingSubTypes = {
  single_use: "single_use"
};
const AccountStatuses = {
  disabled: "disabled",
  active: "active",
  processing: "processing",
  closed: "closed"
};
const AccountCapabilities = {
  payments_receive: "payments:receive",
  payments_send: "payments:send",
  data_retrieve: "data:retrieve",
  data_sync: "data:sync"
};
const AccountLiabilityPaymentStatuses = {
  active: "active",
  activating: "activating",
  unavailable: "unavailable"
};
const AccountLiabilityDataStatuses = {
  active: "active",
  syncing: "syncing",
  unavailable: "unavailable",
  failed: "failed",
  pending: "pending"
};
const AccountLiabilitySyncTypes = {
  manual: "manual",
  auto: "auto"
};
const TradelineAccountOwnership = {
  primary: "primary",
  authorized: "authorized",
  joint: "joint",
  unknown: "unknown"
};
const AccountLiabilityDataSources = {
  credit_report: "credit_report",
  financial_institution: "financial_institution",
  unavailable: "unavailable"
};
const AccountLiabilityTypes = {
  student_loan: "student_loan",
  credit_card: "credit_card",
  mortgage: "mortgage",
  auto_loan: "auto_loan",
  collection: "collection",
  personal_loan: "personal_loan",
  business_loan: "business_loan",
  insurance: "insurance",
  credit_builder: "credit_builder",
  subscription: "subscription",
  utility: "utility",
  medical: "medical",
  loan: "loan"
};
const PastDueStatuses = {
  unknown: "unknown",
  overdue: "overdue",
  on_time: "on_time"
};
const AutoPayStatuses = {
  unknown: "unknown",
  active: "active",
  inactive: "inactive"
};
class AccountSubResources {
  verification;
  syncs;
  constructor(id, config) {
    this.verification = new Verification(config.addPath(id));
    this.syncs = new AccountSync(config.addPath(id));
  }
}
class Account extends Resource {
  constructor(config) {
    super(config.addPath("accounts"));
  }
  _call(id) {
    return new AccountSubResources(id, this.config);
  }
  async get(id) {
    return super._getWithId(id);
  }
  async list(opts) {
    return super._list(opts);
  }
  async create(data, requestConfig) {
    return super._create(data, requestConfig);
  }
  async getDetails(id) {
    return super._getWithSubPath(`/${id}/details`);
  }
  async bulkSync(acc_ids) {
    return super._createWithSubPath("/bulk_sync", { acc_ids });
  }
  async sync(id) {
    return super._createWithSubPath(`/${id}/syncs`, {});
  }
  async enrollAutoSyncs(id) {
    return super._createWithSubPath(`/${id}/sync_enrollment`, {});
  }
  async unenrollAutoSyncs(id) {
    return super._deleteWithSubPath(`/${id}/sync_enrollment`, {});
  }
  async withdrawConsent(id, data = { type: "withdraw", reason: "holder_withdrew_consent" }) {
    return super._createWithSubPath(`/${id}/consent`, data);
  }
}

const BINBrands = {
  amex: "amex",
  visa: "visa",
  mastercard: "mastercard",
  discover: "discover",
  diners_club: "diners_club"
};
const BINTypes = {
  credit: "credit",
  debit: "debit"
};
class Bin extends Resource {
  constructor(config) {
    super(config.addPath("bins"));
  }
  async get(bin) {
    return super._getWithParams({ bin });
  }
}

const ElementTypes = {
  link: "link",
  auth: "auth"
};
class Element extends Resource {
  constructor(config) {
    super(config.addPath("elements"));
  }
  async createToken(opts) {
    return super._createWithSubPath("/token", opts);
  }
  async exchangePublicAccountToken(public_account_token) {
    return super._createWithSubPath("/accounts/exchange", { public_account_token });
  }
  async exchangePublicAccountTokens(public_account_tokens) {
    return super._createWithSubPath("/accounts/exchange", { public_account_tokens });
  }
}

class EntitySync extends Resource {
  constructor(config) {
    super(config.addPath("syncs"));
  }
  async get(id) {
    return super._getWithId(id);
  }
  async create(data) {
    return super._create(data);
  }
}

const EntityTypes = {
  individual: "individual",
  c_corporation: "c_corporation",
  s_corporation: "s_corporation",
  llc: "llc",
  partnership: "partnership",
  sole_proprietorship: "sole_proprietorship",
  receive_only: "receive_only"
};
const EntityCapabilities = {
  payments_send: "payments:send",
  payments_receive: "payments:receive",
  payments_limited_send: "payments:limited-send",
  data_retrieve: "data:retrieve",
  data_sync: "data:sync"
};
const EntityStatuses = {
  active: "active",
  incomplete: "incomplete",
  disabled: "disabled"
};
class EntitySubResources {
  syncs;
  constructor(id, config) {
    this.syncs = new EntitySync(config.addPath(id));
  }
}
class Entity extends Resource {
  constructor(config) {
    super(config.addPath("entities"));
  }
  _call(id) {
    return new EntitySubResources(id, this.config);
  }
  async create(opts, requestConfig) {
    return super._create(opts, requestConfig);
  }
  async update(id, opts) {
    return super._updateWithId(id, opts);
  }
  async get(id) {
    return super._getWithId(id);
  }
  async list(opts) {
    return super._list(opts);
  }
  async createAuthSession(id) {
    return super._createWithSubPath(`/${id}/auth_session`, {});
  }
  async updateAuthSession(id, opts) {
    return super._updateWithSubPath(`/${id}/auth_session`, opts);
  }
  async refreshCapabilities(id) {
    return super._createWithSubPath(`/${id}/refresh_capabilities`, {});
  }
  async getCreditScore(id) {
    return super._getWithSubPath(`/${id}/credit_score`);
  }
  async withdrawConsent(id, data = { type: "withdraw", reason: "entity_withdrew_consent" }) {
    return super._createWithSubPath(`/${id}/consent`, data);
  }
}

const MerchantTypes = {
  auto_loan: "auto_loan",
  business_loan: "business_loan",
  credit_card: "credit_card",
  electric_utility: "electric_utility",
  home_loan: "home_loan",
  insurance: "insurance",
  internet_utility: "internet_utility",
  loan: "loan",
  medical: "medical",
  personal_loan: "personal_loan",
  student_loan: "student_loan",
  telephone_utility: "telephone_utility",
  television_utility: "television_utility",
  water_utility: "water_utility",
  bank: "bank",
  home_equity_loan: "home_equity_loan",
  mortgage: "mortgage",
  utility: "utility",
  waste_utility: "waste_utility"
};
class Merchant extends Resource {
  constructor(config) {
    super(config.addPath("merchants"));
  }
  async get(id) {
    return super._getWithId(id);
  }
  async list(opts) {
    return super._list(opts);
  }
}

class Reversal extends Resource {
  constructor(config) {
    super(config.addPath("reversals"));
  }
  async get(id) {
    return super._getWithId(id);
  }
  async list() {
    return super._list();
  }
  async update(id, data) {
    return super._updateWithId(id, data);
  }
}

const PaymentStatuses = {
  pending: "pending",
  canceled: "canceled",
  processing: "processing",
  failed: "failed",
  sent: "sent",
  reversed: "reversed",
  reversal_required: "reversal_required",
  reversal_processing: "reversal_processing"
};
const PaymentFundStatuses = {
  hold: "hold",
  pending: "pending",
  requested: "requested",
  clearing: "clearing",
  failed: "failed",
  sent: "sent",
  unknown: "unknown"
};
const PaymentTypes = {
  standard: "standard",
  clearing: "clearing"
};
const PaymentFeeTypes = {
  total: "total",
  markup: "markup"
};
class PaymentSubResources {
  reversals;
  constructor(id, config) {
    this.reversals = new Reversal(config.addPath(id));
  }
}
class Payment extends Resource {
  constructor(config) {
    super(config.addPath("payments"));
  }
  _call(id) {
    return new PaymentSubResources(id, this.config);
  }
  async get(id) {
    return super._getWithId(id);
  }
  async list(opts) {
    return super._list(opts);
  }
  async create(opts, requestConfig) {
    return super._create(opts, requestConfig);
  }
  async delete(id) {
    return super._delete(id);
  }
}

const ReportTypes = {
  payments_created_current: "payments.created.current",
  payments_created_previous: "payments.created.previous",
  payments_updated_current: "payments.updated.current",
  payments_updated_previous: "payments.updated.previous"
};
const ReportStatuses = {
  processing: "processing",
  completed: "completed"
};
class Report extends Resource {
  constructor(config) {
    super(config.addPath("reports"));
  }
  async get(id) {
    return super._getWithId(id);
  }
  async create(opts, requestConfig) {
    return super._create(opts, requestConfig);
  }
  async download(id) {
    return super._download(id);
  }
}

const RoutingNumberOfficeTypes = {
  main: "main",
  branch: "branch"
};
class RoutingNumber extends Resource {
  constructor(config) {
    super(config.addPath("routing_numbers"));
  }
  async get(routing_number) {
    return super._getWithParams({ routing_number });
  }
}

const WebhookTypes = {
  payment_create: "payment.create",
  payment_update: "payment.update",
  account_create: "account.create",
  account_update: "account.update",
  entity_update: "entity.update",
  entity_create: "entity.create",
  account_verification_create: "account_verification.create",
  account_verification_update: "account_verification.update",
  payment_reversal_create: "payment_reversal.create",
  payment_reversal_update: "payment_reversal.update",
  connection_create: "connection.create",
  connection_update: "connection.update",
  account_verification_sent: "account_verification.sent",
  account_verification_returned: "account_verification.returned"
};
class Webhook extends Resource {
  constructor(config) {
    super(config.addPath("webhooks"));
  }
  async get(id) {
    return super._getWithId(id);
  }
  async delete(id) {
    return super._delete(id);
  }
  async list() {
    return super._list();
  }
  async create(opts, requestConfig) {
    return super._create(opts, requestConfig);
  }
}

class HealthCheck extends Resource {
  constructor(config) {
    super(config.addPath("ping"));
  }
  async get() {
    return super._getRaw();
  }
}

class Connection extends Resource {
  constructor(config) {
    super(config.addPath("connections"));
  }
  async list() {
    return super._list();
  }
  async get(id) {
    return super._getWithId(id);
  }
  async update(id, opts) {
    return super._updateWithId(id, opts);
  }
  async getPublicAccountTokens(id) {
    return super._getWithSubPath(`/${id}/public_account_tokens`);
  }
}

class SimulatePayment extends Resource {
  constructor(config) {
    super(config.addPath("payments"));
  }
  async update(id, data) {
    return super._postWithId(id, data);
  }
}

class Simulate extends Resource {
  payments;
  constructor(config) {
    const _config = config.addPath("simulate");
    super(_config);
    this.payments = new SimulatePayment(_config);
  }
}

class Method {
  accounts;
  bins;
  elements;
  entities;
  merchants;
  payments;
  reports;
  routingNumbers;
  webhooks;
  healthcheck;
  connections;
  simulate;
  constructor(opts) {
    const config = new Configuration(opts);
    this.accounts = new Account(config);
    this.bins = new Bin(config);
    this.elements = new Element(config);
    this.entities = new Entity(config);
    this.merchants = new Merchant(config);
    this.payments = new Payment(config);
    this.reports = new Report(config);
    this.routingNumbers = new RoutingNumber(config);
    this.webhooks = new Webhook(config);
    this.healthcheck = new HealthCheck(config);
    this.connections = new Connection(config);
    this.simulate = new Simulate(config);
  }
  async ping() {
    return this.healthcheck.get();
  }
}

export { AccountCapabilities, AccountClearingSubTypes, AccountLiabilityDataSources, AccountLiabilityDataStatuses, AccountLiabilityPaymentStatuses, AccountLiabilitySyncTypes, AccountLiabilityTypes, AccountStatuses, AccountSubResources, AccountSubTypes, AccountTypes, AutoPayStatuses, BINBrands, BINTypes, ElementTypes, EntityCapabilities, EntityStatuses, EntitySubResources, EntityTypes, Environments, MerchantTypes, Method, MethodAuthorizationError, MethodError, MethodInternalError, MethodInvalidRequestError, PastDueStatuses, PaymentFeeTypes, PaymentFundStatuses, PaymentStatuses, PaymentSubResources, PaymentTypes, ReportStatuses, ReportTypes, RoutingNumberOfficeTypes, TradelineAccountOwnership, WebhookTypes };
//# sourceMappingURL=index.ts.mjs.map
